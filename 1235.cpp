// Online Judge 当前用户：517030910356 服务器时间：2018-12-07 16:25:01
// 首页
// 题库
// 比赛
// 作业
// 提交
// 评测状态
// 1235. Dijkstra
// Description
// 欢迎来到最后一题！

// 在做这一题之前，在我做古怪的事情之前，请先保证你对dijkstra算法（P382左右）以及优先队列堆（P158开始的内容）有充分的理解。

// 为了减少负担，3,6两题被浓缩成了一题。我们要用dijkstra算法实现求单源最短路径。我想你应该已经猜到了，你将遇到一些稀疏图（边数较少）而，图中结点个数n会很大（0<n<=10000），这导致朴素的dijkstra算法无法在规定的时间快速出解。所以你要用堆去优化它（请看P393,14.6的提示），使得每次获得具有最短路径的结点的时间复杂度由朴素算法的O（n）降到O（logn）。只有这样，你才能完成要求。给定无负权的有向图，起点start，终点end，请计算由start到end的最短路径（若存在多条最短路径，保留经过结点最少的那条）。

// 为简化题目，我们约定：用正整数1,2,3⋯⋯n来表示每个结点的ID（编号）

// Input Format
// 第1行：n m start end //正整数n ，代表图中结点的数量。非负整数m代表要图中有向边的数量。

// 第2行到第1+m行: a b p //每行两个整数：代表结点a到结点b有一条有向边（a->b），权值为p

// Output Format
// 第一行：一个整数，由start到end的最短路径上边的总权值的大小。

// 第二行：若干个整数，依次代表由起点到终点的最短路径上的结点，由空格分隔（若存在多条最短路径，输出经过结点最少的那条）

// Sample Input
// 7 12 4 6
// 1 2 2
// 3 1 4
// 1 4 1
// 2 4 3
// 4 5 2
// 2 5 10
// 3 6 5
// 4 6 8
// 4 7 4 
// 5 7 6
// 7 6 1
// 4 3 2
// Sample Output
// 5                      //P382的例子
// 4 7 6
// Limits
// 0<n<=10000 0<=m<=200000

// 数据保证合法

// 两点之间可能有多条路径，也可能有自环

// 注：此题难度较大，若遇到问题，请及时与助教交流！

// 提交此题
// Powered by PHP Technologies | Contributors 
// Copyright © 2011-2018 ACM Class. All rights reserved. 
// 0.0546 - render 0.0149 - instru - 2 queries - 0.0063 @ portal